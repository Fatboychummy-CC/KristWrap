local c=require("cc.expect").expect local d=require("json")local e=require("sha256")local f={}local g=1 local h,i,j,k local l,m=false,false local function n()if not i then error("Websocket not initialized!",3)end end local function o()if not h then error("Endpoint not set!",3)end end local function p(t,u,v)c(1,t,"string")c(2,u,"table","nil")c(3,v,"table","nil")u=u or{}v=v or{}v["Content-Type"]="application/json"return http.post(t,d.encode(u),v)end local function q(t)c(1,t,"table","nil")n()local u=g g=g+1 t=t or{}t.id=u i.send(d.encode(t))while true do local v=i.receive()a=d.decode(v)if a.id==u then return a.ok,a end end end local function r(t)c(1,t,"string","nil")o()f.close()if t then t=f.toKristWalletFormat(t)end local u,v=p(k.."/ws/start",{privatekey=t})if u then local w,x=pcall(d.decode,u.readAll())u.close()if w then if x.ok then if t then l=true end local y,z=http.websocket(x.url)if y then i=y else error(string.format("Websocket connection failure: %s",z))end else error(string.format("Websocket failure: %s",x.error),2)end else error(string.format("Websocket init decode failure: %s",x),2)end else error(string.format("Websocket creation failure: %s",v),2)end end local function s(t)c(1,t,"table")for u=1,#t do local v,w=q({type="subscribe",event=t[u]})if not v then local x=w.error if not x then x="Unknown"end error(string.format("Failed to subscribe to %s: %s",t[u],x),2)end end end function f.makeTransaction(t,u,v,w)c(1,t,"string")c(2,u,"number")u=math.floor(u)c(3,v,"string","nil")c(4,w,"string","nil")if m and not l then error("KristWrap is not authorized to make a transaction in websocket mode! Authorize before attempting to make a transaction!",2)end if not m and not w then error("KristWrap requires an authorization key (4th argument) to make a transaction if KristWrap is not running in websocket mode and authorized.",2)end if m then local x,y=q({type="make_transaction",to=t,amount=u,metadata=v})if x then return true end return false,y.error else local x,y,z=p(k.."/transactions/",{privatekey=f.toKristWalletFormat(w),to=t,amount=u,metadata=v})if not x then error(string.format("Bad response. sErr:(%s), handleAll:(%s)",y,z.readAll()))end local A,B=pcall(d.decode,x.readAll())x.close()return B.ok,B.error end end function f.toKristWalletFormat(t)c(1,t,"string")if t:sub(#t-3)=="-000"then return t end return e.digest("KRISTWALLET"..t):toHex().."-000"end function f.getV2Address(t)c(1,t,"string")o()t=f.toKristWalletFormat(t)local u,v=p(k.."/v2",{privatekey=t})if u then b=d.decode(u.readAll())u.close()return b.address end end function f.run(t,u)c(1,t,"table","nil")c(2,u,"string","nil")o()r(u)s(t or{})local v={event=function(z)local A=z.event if A=="transaction"then local B=z.transaction local C,D=pcall(d.decode,B.metadata)if not C then D=B.metadata end os.queueEvent("KristWrap_Transaction",B.from,B.to,B.value,D)end end}local function w()m=true local z=0 while true do local A=i.receive()local B,C=pcall(d.decode,A)if B then z=0 os.queueEvent("websocket_message_decoded",C)if v[C.type]then v[C.type](C)end else z=z+1 if z>10 then error("Failed to decode data from websocket over ten times, stopping.")end end end end local x,y=pcall(w)i.close()m=false if not x then error(y)end end function f.setEndPoint(t)c(1,t,"string")if t:sub(#t,#t)=="/"then t=t:sub(1,#t-1)end h=string.gsub(t,"https?%:%/%/","")h=string.gsub(h,"wss?:%/%/","")j="ws://"..h k="https://"..h end function f.useDefaultEndPoint()f.setEndPoint("krist.ceriat.net")end function f.getEndPoint()return h end function f.close()if i then i.close()end end return f