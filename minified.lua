local a=require("cc.expect").expect;local b=require("json")local c=require("sha256")local d={}local e=1;local f,g,h,i;local j,k=false,false;local l={}local function m(n)a(1,n,"string")return{Fire=function(self,...)os.queueEvent(n,...)end,Wait=function(self,o)a(1,self,"table")a(2,o,"number","nil")if o then o=os.startTimer(o)end;while true do local p=table.pack(os.pullEvent())if p[1]=="timer"and p[2]==o then return elseif p[1]==n then return table.unpack(p,2,p.n)end end end,Connect=function(self,q)a(1,self,"table")a(2,q,"function")if not l[n]then l[n]={}end;local r=#l[n]+1;l[n][r]=q;return{Disconnect=function()for r=1,#l[n]do if l[n][r]==q then table.remove(l[n],r)break end end end}end}end;local function s()if not g then error("Websocket not initialized!",3)end end;local function t()if not f then error("Endpoint not set!",3)end end;local function u(v,tData,w)a(1,v,"string")a(2,tData,"table","nil")a(3,w,"table","nil")tData=tData or{}w=w or{}w["Content-Type"]="application/json"return http.post(v,b.encode(tData),w)end;local function x(tData)a(1,tData,"table","nil")s()local y=e;e=e+1;tData=tData or{}tData.id=y;g.send(b.encode(tData))while true do local z=g.receive()tResponse=b.decode(z)if tResponse.id==y then return tResponse.ok,tResponse end end end;local function A(B)a(1,B,"string","nil")t()d.close()if B then B=d.toKristWalletFormat(B)end;local tResponse,C=u(i.."/ws/start",{privatekey=B})if tResponse then local D,tData=pcall(b.decode,tResponse.readAll())tResponse.close()if D then if tData.ok then if B then j=true end;local z,E=http.websocket(tData.url)if z then g=z else error(string.format("Websocket connection failure: %s",E))end else error(string.format("Websocket failure: %s",tData.error),2)end else error(string.format("Websocket init decode failure: %s",tData),2)end else error(string.format("Websocket creation failure: %s",C),2)end end;local function F(G)a(1,G,"table")for r=1,#G do local D,tResponse=x({type="subscribe",event=G[r]})if not D then local H=tResponse.error;if not H then H="Unknown"end;error(string.format("Failed to subscribe to %s: %s",G[r],H),2)end end end;function d.aboutMe()s()return x({type="me"})end;function d.upgradeWebsocket(B)a(1,B,"string")s()local D,tResponse=x({type="login",privatekey=d.toKristWalletFormat(B)})return D,D and tResponse.address or tResponse.error end;function d.downgradeWebsocket()s()local D,tResponse=x({type="logout"})return D,D and tResponse.isGuest or tResponse.error end;function d.makeTransaction(v,I,J,B)a(1,v,"string")a(2,I,"number")I=math.floor(I)a(3,J,"string","nil")a(4,B,"string","nil")if k and not j then error("KristWrap is not authorized to make a transaction in websocket mode! Authorize before attempting to make a transaction!",2)end;if not k and not B then error("KristWrap requires an authorization key (4th argument) to make a transaction if KristWrap is not running in websocket mode and authorized.",2)end;if k then local D,tResponse=x({type="make_transaction",to=v,amount=I,metadata=J})if D then return true end;return false,tResponse.error else local tResponse,C,K=u(i.."/transactions/",{privatekey=d.toKristWalletFormat(B),to=v,amount=I,metadata=J})if not tResponse then error(string.format("Bad response. sErr:(%s), handleAll:(%s)",C,K.readAll()))end;local L,M=pcall(b.decode,tResponse.readAll())tResponse.close()return M.ok,M.error end end;function d.toKristWalletFormat(N)a(1,N,"string")if N:sub(#N-3)=="-000"then return N end;return c.digest("KRISTWALLET"..N):toHex().."-000"end;function d.getV2Address(N)a(1,N,"string")t()N=d.toKristWalletFormat(N)local tResponse,C=u(i.."/v2",{privatekey=N})if tResponse then tData=b.decode(tResponse.readAll())tResponse.close()return tData.address end end;function d.run(G,B)a(1,G,"table","nil")a(2,B,"string","nil")t()A(B)F(G or{})local O={event=function(tData)local n=tData.event;if n=="transaction"then local P=tData.transaction;local L,Q=pcall(b.decode,P.metadata)if not L then Q=P.metadata end;d.Transaction:Fire(P.from,P.to,P.value,Q)end end}local function R()k=true;local S=0;d.Initialized:Fire()while true do local T=g.receive()local D,tData=pcall(b.decode,T)if D then S=0;d.websocket_message_decoded:Fire(tData)if O[tData.type]then O[tData.type](tData)end else S=S+1;if S>10 then error("Failed to decode data from websocket over ten times, stopping.")end end end end;local function U()while true do local p=table.pack(os.pullEvent())local n=p[1]if l[n]then for r=1,#l[n]do l[n][r](table.unpack(p,2,p.n))end end end end;local D,C=pcall(parallel.waitForAny,R,U)g.close()k=false;if not D then error(C,2)end end;function d.setEndPoint(V)a(1,V,"string")if V:sub(#V,#V)=="/"then V=V:sub(1,#V-1)end;f=string.gsub(V,"https?%:%/%/","")f=string.gsub(f,"wss?:%/%/","")h="ws://"..f;i="https://"..f end;function d.useDefaultEndPoint()d.setEndPoint("krist.ceriat.net")end;function d.getEndPoint()return f end;d.Initialized=m("KristWrap_Initialized")d.Transaction=m("KristWrap_Transaction")d.websocket_message_decoded=m("websocket_message_decoded")function d.close()if g then g.close()g=nil end end;return d
