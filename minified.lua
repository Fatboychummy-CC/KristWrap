local a=require("cc.expect").expect;local b=require("json")local c=require("sha256")local d={}local e=1;local f,g,h,i,j;local k,l=false,false;local m={}local function n(o)a(1,o,"string")return{Fire=function(self,...)os.queueEvent(o,...)end,Wait=function(self,p)a(1,self,"table")a(2,p,"number","nil")if p then p=os.startTimer(p)end;while true do local q=table.pack(os.pullEvent())if q[1]=="timer"and q[2]==p then return elseif q[1]==o then return table.unpack(q,2,q.n)end end end,Connect=function(self,r)a(1,self,"table")a(2,r,"function")if not m[o]then m[o]={}end;local s=#m[o]+1;m[o][s]=r;return{Disconnect=function()for s=1,#m[o]do if m[o][s]==r then table.remove(m[o],s)break end end end}end}end;local function t(tResponse,u,v)if not tResponse then if u then return nil,u elseif v then return nil,v.readAll()else return nil,"Bad response."end end;local w,x=pcall(tResponse.readAll)if not w then return nil,"Failed to read response data."end;local y,z=pcall(b.decode,x)if not y then return nil,"Failed to decode response data."end;return z end;local function A()if not g then error("Websocket not initialized!",3)end end;local function B()if not f then error("Endpoint not set!",3)end end;local function C(D,z,E)a(1,D,"string")a(2,z,"table","nil")a(3,E,"table","nil")z=z or{}E=E or{}E["Content-Type"]="application/json"return http.post(D,b.encode(z),E)end;local function F(z)a(1,z,"table","nil")A()local G=e;e=e+1;z=z or{}z.id=G;g.send(b.encode(z))while true do local H=g.receive()tResponse=b.decode(H)if tResponse.id==G then return tResponse.ok,tResponse end end end;local function I(J)a(1,J,"string","nil")B()d.close()if J then J=d.toKristWalletFormat(J)end;local tResponse,u=C(i.."/ws/start",{privatekey=J})if tResponse then local K,z=pcall(b.decode,tResponse.readAll())tResponse.close()if K then if z.ok then if J then k=true end;local H,L=http.websocket(z.url)j=z.url;if H then g=H else error(string.format("Websocket connection failure: %s",L))end else error(string.format("Websocket failure: %s",z.error),2)end else error(string.format("Websocket init decode failure: %s",z),2)end else error(string.format("Websocket creation failure: %s",u),2)end end;local function M(N)a(1,N,"table")for s=1,#N do local K,tResponse=F({type="subscribe",event=N[s]})if not K then local O=tResponse.error;if not O then O="Unknown"end;error(string.format("Failed to subscribe to %s: %s",N[s],O),2)end end end;function d.getName(P)B()return t(http.get(string.format("%s/names/%s",i,textutils.urlEncode(P))))end;function d.aboutMe()A()return F({type="me"})end;function d.upgradeWebsocket(J)a(1,J,"string")A()local K,tResponse=F({type="login",privatekey=d.toKristWalletFormat(J)})return K,K and tResponse.address or tResponse.error end;function d.downgradeWebsocket()A()local K,tResponse=F({type="logout"})return K,K and tResponse.isGuest or tResponse.error end;function d.makeTransaction(D,Q,R,J)a(1,D,"string")a(2,Q,"number")if Q%1~=0 then error("Bad argument #3: Number should be an integer.",2)end;a(3,R,"string","nil")a(4,J,"string","nil")if l and not k then error("KristWrap is not authorized to make a transaction in websocket mode! Authorize before attempting to make a transaction!",2)end;if not l and not J then error("KristWrap requires an authorization key (4th argument) to make a transaction if KristWrap is not running in websocket mode and authorized.",2)end;if l then local K,tResponse=F({type="make_transaction",to=D,amount=Q,metadata=R})if K then return true end;return false,tResponse.error else local z,u=t(C(i.."/transactions/",{privatekey=d.toKristWalletFormat(J),to=D,amount=Q,metadata=R}))if z then return z.ok or nil,z.error end;return nil,u end end;function d.toKristWalletFormat(S)a(1,S,"string")if S:sub(#S-3)=="-000"then return S end;return c.digest("KRISTWALLET"..S):toHex().."-000"end;function d.getV2Address(S)a(1,S,"string")B()S=d.toKristWalletFormat(S)local T,u,U=t(C(i.."/v2",{privatekey=S}))if T then if T and T.ok then return T.address else return T.error end else return nil,u end end;function d.run(N,J)a(1,N,"table","nil")a(2,J,"string","nil")B()I(J)M(N or{})local V={event=function(z)local o=z.event;if o=="transaction"then local W=z.transaction;d.Transaction:Fire(W.from,W.to,W.value,W.metadata)end end}local function X()assert(j,"Websocket reset before init could complete.")local Y=j;local function Z()while true do local _,a0,a1=os.pullEvent()if _=="websocket_message"and a0==Y then return a1 elseif _=="websocket_closed"and a0==Y then d.close()error("Websocket was closed.")end end end;l=true;local a2=0;d.Initialized:Fire()while true do local x=Z()local K,z=pcall(b.decode,x)if K then a2=0;d.websocket_message_decoded:Fire(z)if V[z.type]then V[z.type](z)end else a2=a2+1;if a2>10 then error("Failed to decode data from websocket over ten times, stopping.")end end end end;local function a3()while true do local q=table.pack(os.pullEvent())local o=q[1]if m[o]then for s=1,#m[o]do m[o][s](table.unpack(q,2,q.n))end end end end;local K,u=pcall(parallel.waitForAny,X,a3)pcall(d.close)l=false;if not K then error(u,2)end end;function d.setEndPoint(a4)a(1,a4,"string")if a4:sub(#a4,#a4)=="/"then a4=a4:sub(1,#a4-1)end;f=string.gsub(a4,"https?%:%/%/","")f=string.gsub(f,"wss?:%/%/","")h="ws://"..f;i="https://"..f end;function d.useDefaultEndPoint()d.setEndPoint("krist.ceriat.net")end;function d.getDefaultEndPoint()return"krist.ceriat.net"end;function d.getEndPoint()return f end;d.Initialized=n("KristWrap_Initialized")d.Transaction=n("KristWrap_Transaction")d.websocket_message_decoded=n("websocket_message_decoded")function d.close()if g then g.close()os.queueEvent("websocket_closed",j)g=nil;j=nil end end;return d
