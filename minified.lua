local a=require("cc.expect").expect;local b=require("json")local c=require("sha256")local d={}local e=1;local f,g,h,i;local j,k=false,false;local l={}local function m(n)a(1,n,"string")return{Fire=function(self,...)os.queueEvent(n,...)end,Wait=function(self,o)a(1,self,"table")a(2,o,"number","nil")if o then o=os.startTimer(o)end;while true do local p=table.pack(os.pullEvent())if p[1]=="timer"and p[2]==o then return elseif p[1]==n then return table.unpack(p,2,p.n)end end end,Connect=function(self,q)a(1,self,"table")a(2,q,"function")if not l[n]then l[n]={}end;local r=#l[n]+1;l[n][r]=q;return{Disconnect=function()for r=1,#l[n]do if l[n][r]==q then table.remove(l[n],r)break end end end}end}end;local function s(tResponse,t,u)if not tResponse then if t then return nil,t elseif u then return nil,u.readAll()else return nil,"Bad response."end end;local v,w=pcall(tResponse.readAll)if not v then return nil,"Failed to read response data."end;local x,y=pcall(b.decode,w)if not x then return nil,"Failed to decode response data."end;return y end;local function z()if not g then error("Websocket not initialized!",3)end end;local function A()if not f then error("Endpoint not set!",3)end end;local function B(C,y,D)a(1,C,"string")a(2,y,"table","nil")a(3,D,"table","nil")y=y or{}D=D or{}D["Content-Type"]="application/json"return http.post(C,b.encode(y),D)end;local function E(y)a(1,y,"table","nil")z()local F=e;e=e+1;y=y or{}y.id=F;g.send(b.encode(y))while true do local G=g.receive()tResponse=b.decode(G)if tResponse.id==F then return tResponse.ok,tResponse end end end;local function H(I)a(1,I,"string","nil")A()d.close()if I then I=d.toKristWalletFormat(I)end;local tResponse,t=B(i.."/ws/start",{privatekey=I})if tResponse then local J,y=pcall(b.decode,tResponse.readAll())tResponse.close()if J then if y.ok then if I then j=true end;local G,K=http.websocket(y.url)if G then g=G else error(string.format("Websocket connection failure: %s",K))end else error(string.format("Websocket failure: %s",y.error),2)end else error(string.format("Websocket init decode failure: %s",y),2)end else error(string.format("Websocket creation failure: %s",t),2)end end;local function L(M)a(1,M,"table")for r=1,#M do local J,tResponse=E({type="subscribe",event=M[r]})if not J then local N=tResponse.error;if not N then N="Unknown"end;error(string.format("Failed to subscribe to %s: %s",M[r],N),2)end end end;function d.aboutMe()z()return E({type="me"})end;function d.upgradeWebsocket(I)a(1,I,"string")z()local J,tResponse=E({type="login",privatekey=d.toKristWalletFormat(I)})return J,J and tResponse.address or tResponse.error end;function d.downgradeWebsocket()z()local J,tResponse=E({type="logout"})return J,J and tResponse.isGuest or tResponse.error end;function d.makeTransaction(C,O,P,I)a(1,C,"string")a(2,O,"number")if O%1~=0 then error("Bad argument #3: Number should be an integer.",2)end;a(3,P,"string","nil")a(4,I,"string","nil")if k and not j then error("KristWrap is not authorized to make a transaction in websocket mode! Authorize before attempting to make a transaction!",2)end;if not k and not I then error("KristWrap requires an authorization key (4th argument) to make a transaction if KristWrap is not running in websocket mode and authorized.",2)end;if k then local J,tResponse=E({type="make_transaction",to=C,amount=O,metadata=P})if J then return true end;return false,tResponse.error else local y,t=s(B(i.."/transactions/",{privatekey=d.toKristWalletFormat(I),to=C,amount=O,metadata=P}))if y then return y.ok or nil,y.error end;return nil,t end end;function d.toKristWalletFormat(Q)a(1,Q,"string")if Q:sub(#Q-3)=="-000"then return Q end;return c.digest("KRISTWALLET"..Q):toHex().."-000"end;function d.getV2Address(Q)a(1,Q,"string")A()Q=d.toKristWalletFormat(Q)return s(B(i.."/v2",{privatekey=Q}))end;function d.run(M,I)a(1,M,"table","nil")a(2,I,"string","nil")A()H(I)L(M or{})local R={event=function(y)local n=y.event;if n=="transaction"then local S=y.transaction;local T,U=pcall(b.decode,S.metadata)if not T then U=S.metadata end;d.Transaction:Fire(S.from,S.to,S.value,U)end end}local function V()k=true;local W=0;d.Initialized:Fire()while true do local w=g.receive()local J,y=pcall(b.decode,w)if J then W=0;d.websocket_message_decoded:Fire(y)if R[y.type]then R[y.type](y)end else W=W+1;if W>10 then error("Failed to decode data from websocket over ten times, stopping.")end end end end;local function X()while true do local p=table.pack(os.pullEvent())local n=p[1]if l[n]then for r=1,#l[n]do l[n][r](table.unpack(p,2,p.n))end end end end;local J,t=pcall(parallel.waitForAny,V,X)g.close()k=false;if not J then error(t,2)end end;function d.setEndPoint(Y)a(1,Y,"string")if Y:sub(#Y,#Y)=="/"then Y=Y:sub(1,#Y-1)end;f=string.gsub(Y,"https?%:%/%/","")f=string.gsub(f,"wss?:%/%/","")h="ws://"..f;i="https://"..f end;function d.useDefaultEndPoint()d.setEndPoint("krist.ceriat.net")end;function d.getEndPoint()return f end;d.Initialized=m("KristWrap_Initialized")d.Transaction=m("KristWrap_Transaction")d.websocket_message_decoded=m("websocket_message_decoded")function d.close()if g then g.close()g=nil end end;return d
