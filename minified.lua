local a=require("cc.expect").expect;local b=require("json")local c=require("sha256")local d={}local e=1;local f,g,h,i,j;local k,l,m=false,false,false;local n={}local function o(p)a(1,p,"string")return{Fire=function(self,...)os.queueEvent(p,...)end,Wait=function(self,q)a(1,self,"table")a(2,q,"number","nil")if q then q=os.startTimer(q)end;while true do local r=table.pack(os.pullEvent())if r[1]=="timer"and r[2]==q then return elseif r[1]==p then return table.unpack(r,2,r.n)end end end,Connect=function(self,s)a(1,self,"table")a(2,s,"function")if not n[p]then n[p]={}end;local t=#n[p]+1;n[p][t]=s;return{Disconnect=function()for t=1,#n[p]do if n[p][t]==s then table.remove(n[p],t)break end end end}end}end;local function u(tResponse,v,w)if not tResponse then if v then return nil,v elseif w then return nil,w.readAll()else return nil,"Bad response."end end;local x,y=pcall(tResponse.readAll)if not x then return nil,"Failed to read response data."end;local z,A=pcall(b.decode,y)if not z then return nil,"Failed to decode response data."end;return A end;local function B()if not g then error("Websocket not initialized!",3)end end;local function C()if not f then error("Endpoint not set!",3)end end;local function D(E,A,F)a(1,E,"string")a(2,A,"table","nil")a(3,F,"table","nil")A=A or{}F=F or{}F["Content-Type"]="application/json"return http.post(E,b.encode(A),F)end;local function G(A)a(1,A,"table","nil")B()local H=e;e=e+1;A=A or{}A.id=H;g.send(b.encode(A))while true do local I=g.receive()tResponse=b.decode(I)if tResponse.id==H then return tResponse.ok,tResponse end end end;local function J(K)a(1,K,"string","nil")C()d.close()if K then K=d.toKristWalletFormat(K)end;local tResponse,v=D(i.."/ws/start",{privatekey=K})if tResponse then local L,A=pcall(b.decode,tResponse.readAll())tResponse.close()if L then if A.ok then if K then k=true end;local I,M=http.websocket(A.url)j=A.url;if I then g=I else error(string.format("Websocket connection failure: %s",M))end else error(string.format("Websocket failure: %s",A.error),2)end else error(string.format("Websocket init decode failure: %s",A),2)end else error(string.format("Websocket creation failure: %s",v),2)end end;local function N(O)a(1,O,"table")for t=1,#O do local L,tResponse=G({type="subscribe",event=O[t]})if not L then local P=tResponse.error;if not P then P="Unknown"end;error(string.format("Failed to subscribe to %s: %s",O[t],P),2)end end end;function d.getName(Q)C()return u(http.get(string.format("%s/names/%s",i,textutils.urlEncode(Q))))end;function d.aboutMe()B()return G({type="me"})end;function d.upgradeWebsocket(K)a(1,K,"string")B()local L,tResponse=G({type="login",privatekey=d.toKristWalletFormat(K)})return L,L and tResponse.address or tResponse.error end;function d.downgradeWebsocket()B()local L,tResponse=G({type="logout"})return L,L and tResponse.isGuest or tResponse.error end;function d.makeTransaction(E,R,S,K)a(1,E,"string")a(2,R,"number")if R%1~=0 then error("Bad argument #3: Number should be an integer.",2)end;a(3,S,"string","nil")a(4,K,"string","nil")if l and not k then error("KristWrap is not authorized to make a transaction in websocket mode! Authorize before attempting to make a transaction!",2)end;if not l and not K then error("KristWrap requires an authorization key (4th argument) to make a transaction if KristWrap is not running in websocket mode and authorized.",2)end;if l then local L,tResponse=G({type="make_transaction",to=E,amount=R,metadata=S})if L then return true end;return false,tResponse.error else local A,v=u(D(i.."/transactions/",{privatekey=d.toKristWalletFormat(K),to=E,amount=R,metadata=S}))if A then return A.ok or nil,A.error end;return nil,v end end;function d.toKristWalletFormat(T)a(1,T,"string")if T:sub(#T-3)=="-000"then return T end;return c.digest("KRISTWALLET"..T):toHex().."-000"end;function d.getV2Address(T)a(1,T,"string")C()T=d.toKristWalletFormat(T)local U,v,V=u(D(i.."/v2",{privatekey=T}))if U then if U and U.ok then return U.address else return U.error end else return nil,v end end;function d.run(O,K)a(1,O,"table","nil")a(2,K,"string","nil")C()J(K)N(O or{})local W={event=function(A)local p=A.event;if p=="transaction"then local X=A.transaction;d.Transaction:Fire(X.from,X.to,X.value,X.metadata)end end}local function Y()assert(j,"Websocket reset before init could complete.")local Z=j;local function _()while true do local a0,a1,a2=os.pullEvent()if a0=="websocket_message"and a1==Z then return a2 elseif a0=="websocket_closed"and a1==Z then d.close()error("Websocket was closed.")end end end;l=true;local a3=0;d.Initialized:Fire()while true do local y=_()local L,A=pcall(b.decode,y)if L then a3=0;d.websocket_message_decoded:Fire(A)if W[A.type]then W[A.type](A)end else a3=a3+1;if a3>10 then error("Failed to decode data from websocket over ten times, stopping.")end end end end;local function a4()while true do local r=table.pack(os.pullEvent())local p=r[1]if n[p]then for t=1,#n[p]do n[p][t](table.unpack(r,2,r.n))end end end end;local a5={}local function a6()while true do local r=table.pack(os.pullEvent("KristWrap_Transaction"))if m then table.insert(a5,r)end end end;local function a7()while true do if not m and a5[1]then os.queueEvent(table.unpack(a5[1]))table.remove(a5,1)end;os.sleep(1)end end;local L,v=pcall(parallel.waitForAny,Y,a4,a6,a7)pcall(d.close)l=false;if not L then error(v,2)end end;function d.setQueueEnabled(a8)a(1,a8,"boolean")m=a8 end;function d.setEndPoint(a9)a(1,a9,"string")if a9:sub(#a9,#a9)=="/"then a9=a9:sub(1,#a9-1)end;f=string.gsub(a9,"https?%:%/%/","")f=string.gsub(f,"wss?:%/%/","")h="ws://"..f;i="https://"..f end;function d.useDefaultEndPoint()d.setEndPoint("krist.ceriat.net")end;function d.getDefaultEndPoint()return"krist.ceriat.net"end;function d.getEndPoint()return f end;d.Initialized=o("KristWrap_Initialized")d.Transaction=o("KristWrap_Transaction")d.websocket_message_decoded=o("websocket_message_decoded")function d.close()if g then g.close()os.queueEvent("websocket_closed",j)g=nil;j=nil end end;return d
